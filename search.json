[{"path":"https://lhdjung.github.io/moder/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 moder authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://lhdjung.github.io/moder/articles/metadata.html","id":"modal-count","dir":"Articles","previous_headings":"","what":"Modal count","title":"Modal counts and frequencies","text":"mode_count() computes number modes: Even missing values, number modes sometimes known. can 1 even NA secretly \"b\", \"b\" appear twice, \"\" appear three times: works full set modes can determined. , NA secretly 7, 8, value. ’s 8, numbers equally frequent. Otherwise, 7 mode. Since lack information, number modes unknown. Use mode_count_range() cases. determine minimal maximal number modes, never returning NA. mode_count_range(), see , section Maximal number unique values.","code":"mode_count(c(5, 5, 6)) #> [1] 1 mode_count(c(5, 5, 6, 6, 7)) #> [1] 2 mode_count(c(\"a\", \"a\", \"a\", \"b\", NA)) #> [1] 1 mode_count(c(7, 7, 7, 8, 8, NA)) #> [1] NA mode_count_range(c(7, 7, 7, 8, 8, NA)) #> [1] 1 2"},{"path":"https://lhdjung.github.io/moder/articles/metadata.html","id":"modal-frequency","dir":"Articles","previous_headings":"","what":"Modal frequency","title":"Modal counts and frequencies","text":"mode_frequency() counts instances vector’s modes vector: Missing values issue , even mode obvious. NA might another instance mode, frequency unknown: mode_frequency_range(), least minimal maximal frequencies can determined. never returns NA. minimum frequency supposes NAs represent mode; maximum frequency supposes . way, four instances 1 without counting NAs, six counting :","code":"mode_frequency(c(4, 4, 5)) #> [1] 2 mode_frequency(c(4, 4, 4, 5)) #> [1] 3 mode_frequency(c(1, 1, 1, 1, 2, NA, NA)) #> [1] NA mode_frequency_range(c(1, 1, 1, 1, 2, NA, NA)) #> [1] 4 6"},{"path":"https://lhdjung.github.io/moder/articles/metadata.html","id":"trivial-modes","dir":"Articles","previous_headings":"Modal frequency","what":"Trivial modes","title":"Modal counts and frequencies","text":"Related frequencies, mode_is_trivial() flags cases mode meaningful. returns TRUE values equally frequent. Modality trivial case property values taken together, values others.","code":"mode_is_trivial(c(\"a\", \"b\", \"c\")) #> [1] TRUE mode_is_trivial(c(1, 1, 2, 2, 3, 3)) #> [1] TRUE mode_is_trivial(c(1, 1, 1, 2, 3)) #> [1] FALSE"},{"path":"https://lhdjung.github.io/moder/articles/metadata.html","id":"maximal-number-of-unique-values","dir":"Articles","previous_headings":"","what":"Maximal number of unique values","title":"Modal counts and frequencies","text":"moder’s functions metadata, mode_is_trivial() mode_count_range(), max_unique argument. allows state many unique values data can maximum. important? two functions care possible modes beyond known values. words, results might depend whether NAs can mask modal values don’t even occur among known values! possible, presents additional source uncertainty. Conversely, max_unique limits possible number wildcard modes. Specify integer maximal number unique values. can values already known, specify max_unique \"known\" instead. Always use \"known\" factor data get warning. (idea behind factors possible values known outset.) Note argument represent analytical decision simply conveys knowledge data computer. meaningful choice make: maximum number unique values known, must specify max_unique; , must . Otherwise, risk incorrect results values missing. default NULL baseline assumption always nothing known missing values except number. example. two NAs represent 8 three stand third value, values appear frequency. case, values trivially modes sense mode_is_trivial(). scenario certain , can’t ruled either, function returns NA. mode_count_range() shows, three modes . (minimum always one values missing.) picture different know missing value must represent known value, .e., 7 8. Even two NAs stand 8, three can’t evenly distributed across 7 8, one values must frequent one. makes mode nontrivial. Also, can one mode, minimal maximal mode counts 1. Three functions max_unique parameter: mode_count(), mode_frequency(), mode_frequency_range(). However, matters corner cases. See Github issue.","code":"x3 <- c(7, 7, 7, 8, NA, NA, NA, NA, NA) mode_is_trivial(x3) #> [1] NA mode_count_range(x3) #> [1] 1 3 x3 #> [1]  7  7  7  8 NA NA NA NA NA mode_is_trivial(x3, max_unique = \"known\") #> [1] FALSE mode_count_range(x3, max_unique = \"known\") #> [1] 1 1"},{"path":[]},{"path":"https://lhdjung.github.io/moder/articles/missings.html","id":"general-points","dir":"Articles","previous_headings":"1. Return NA only if question can’t be answered","what":"General points","title":"Modes and missing values","text":"NA value shows data. placeholder values don’t know, treat accordingly. mean() median() sometimes return NA: don’t know true value behind NA, don’t know influence mean median. always true mean (median).1 mode? Missing values sometimes, always, render unknown. Therefore, mode implementations require special care nuance. x1, know 7 mode. appears three times, even NA actually 8 9, value appear three times, well. means know one mode, necessarily whole set modes. mode_first() happy return 7, mode_all() insists complete set modes. can’t determined, function returns NA: distributions clear set modes even though values missing. , 1 frequent 0 even NA masks another 0: mode_single() ? calls mode_all() internally, handles missing values just like function . Differences occur mode_all() returns multiple modes.","code":"x1 <- c(7, 7, 7, 8, 8, 9, 9, NA) mean(x1) #> [1] NA median(x1) #> [1] NA x1 #> [1]  7  7  7  8  8  9  9 NA mode_first(x1) #> [1] 7 mode_all(x1) #> [1] NA x2 <- c(1, 1, 1, 1, 1, 0, 0, NA, NA) mode_first(x2) #> [1] 1 mode_all(x2) #> [1] 1"},{"path":"https://lhdjung.github.io/moder/articles/missings.html","id":"modal-metadata","dir":"Articles","previous_headings":"1. Return NA only if question can’t be answered","what":"Modal metadata","title":"Modes and missing values","text":"functions attempt find modal values. However, moder also functions concerned particular modes assess metadata, modal frequency. can sometimes obtain useful information mode_first() friends return NA. Even number frequency modes can’t determined, least range can given. See vignette(\"metadata\") learn . particular, metadata functions max_unique argument. allows encode knowledge might missing values data. See vignette(\"metadata\"), section Maximal number unique values.","code":""},{"path":"https://lhdjung.github.io/moder/articles/missings.html","id":"possible-minimal-and-maximal-sets-of-modes","dir":"Articles","previous_headings":"1. Return NA only if question can’t be answered","what":"Possible (minimal and maximal) sets of modes","title":"Modes and missing values","text":"might want find values known modes, even missing values make unclear whether certain values . Use mode_possible_min() . can think function less strict version mode_all(): also takes modes can find, unlike mode_all(), doesn’t insist full set modes. Either 8 9 may mode, depending NA, 7 mode case: , \"\" definitely mode, \"b\" mode missing value also \"b\", \"c\" can’t mode: distributions may clear minimum many values missing. NAs FALSE, FALSE mode. Otherwise, TRUE : mirror image mode_possible_min() mode_possible_max(). returns greatest possible set modes, given number missing values. theoretical maximum, function can return values guaranteed modes! , \"\" known mode, \"b\" may mode, \"c\" can’t one: clear maximum x1 either 8 9 can mode, together. one 7, though, 7 frequent anyways:","code":"x1 #> [1]  7  7  7  8  8  9  9 NA mode_possible_min(x1) #> [1] 7 mode_possible_min(c(\"a\", \"a\", \"a\", \"b\", \"b\", \"c\", NA)) #> [1] \"a\" mode_possible_min(c(TRUE, TRUE, FALSE, NA, NA)) #> [1] NA mode_possible_max(c(\"a\", \"a\", \"a\", \"b\", \"b\", \"c\", NA)) #> [1] \"a\" \"b\" x1 #> [1]  7  7  7  8  8  9  9 NA mode_possible_max(x1) #> [1] NA mode_possible_max(c(x1, 7)) #> [1] 7"},{"path":[]},{"path":"https://lhdjung.github.io/moder/articles/missings.html","id":"ignoring-nas","dir":"Articles","previous_headings":"2. Still return non-NA value only if chosen by user","what":"Ignoring NAs","title":"Modes and missing values","text":"moder function attempts determine (actual) modes na.rm argument. works exactly like mean() median(): ’s FALSE default, user sets TRUE, missing values removed x statistic computed. think really carefully removing NAs. sure missing values unnecessary answer specific question? approach makes sure inform user data can’t answer questions. might still choose ignore missings, always require explicit statement. way, users know , can make decisions data analysis.","code":"x1 #> [1]  7  7  7  8  8  9  9 NA mean(x1, na.rm = TRUE) #> [1] 7.857143 median(x1, na.rm = TRUE) #> [1] 8 mode_all(x1, na.rm = TRUE) #> [1] 7"},{"path":"https://lhdjung.github.io/moder/articles/missings.html","id":"the-first-known-mode","dir":"Articles","previous_headings":"2. Still return non-NA value only if chosen by user","what":"The first known mode","title":"Modes and missing values","text":"mode_first() Boolean accept argument FALSE default. set TRUE, function pick first value known mode. means won’t strictly look first-appearing value mode, accept first value mode without counting NAs favor: NAs might 6, known 6 appears start, might first mode. ’s unclear, get NA default. However, 4 first value know mode. Setting accept TRUE makes function pragmatically accept 4 — want find mode, , know one.","code":"x4 <- c(6, 4, 4, 4, NA, NA, 1) mode_first(x4) #> [1] NA mode_first(x4, accept = TRUE) #> [1] 4"},{"path":"https://lhdjung.github.io/moder/articles/missings.html","id":"minimum-and-complete-sets-of-modes","dir":"Articles","previous_headings":"2. Still return non-NA value only if chosen by user","what":"Minimum and complete sets of modes","title":"Modes and missing values","text":"mode_single() well, accept FALSE default. purpose check whether exactly one mode using complete set modes, minimum set just happens known. Set accept TRUE avoid returning NA one mode known, modes :","code":"x5 <- c(4, 4, 4, 7, 7, NA) mode_single(x5) #> [1] NA mode_single(x5, accept = TRUE) #> [1] 4"},{"path":[]},{"path":"https://lhdjung.github.io/moder/articles/missings.html","id":"taking-nas-seriously-enough","dir":"Articles","previous_headings":"Theory","what":"Taking NAs seriously enough","title":"Modes and missing values","text":"earlier mode functions R treat NA like known constant value. suboptimal NA means value missing. approach effectively assumes NAs represent unknown value, ’s different known values (although ’m sure intention). Rather forming distinct cohesive group, however, NAs may represent one known unknown values, procedure can distort data. Consider NA == NA returns NA: two values unknown, ’s also unknown whether equal (Wickham 2019, ch. 3.2.3). ’s , categorizing missing values separate group actually imputation strategy — perhaps wise one. think imputation default job operations supposed simply determine statistic. moder functions treat NAs genuinely missing values, just like mean(), median(), language primitives == . Sometimes, means functions can just ignore known value frequent next--frequent value NAs taken together. return NA user’s question possibly answered data. choices imputation left user. way, moder functions draw clear line estimation imputation.","code":""},{"path":"https://lhdjung.github.io/moder/articles/missings.html","id":"not-taking-nas-too-seriously","dir":"Articles","previous_headings":"Theory","what":"Not taking NAs too seriously","title":"Modes and missing values","text":"Certain mode implementations return NA whenever input vector contains NAs . necessary — fact, ’s overly conservative. seen distribution may clear set modes even values missing. marked difference mean(), missings really make estimation impossible. depends relation counts: frequent known value least frequent sum counts second--frequent known value missing values? , value known mode. Note mode_first(), mode_all() mode_single() don’t allow ties among known values values missing (return NA). missings may secretly count “tied” known value, break tie. vector like c(1, 1, NA), mode clearly 1, matter NA stands . just clear c(1, 1, 2). mode function returns NA instead 1 incorrect c(1, 1, 2), just incorrect c(1, 1, NA). , think parallels base R. NA ^ 2 returns NA, NA ^ 0 returns 1. second case, don’t need know true value behind NA determine result. knowledge built R (Wickham 2019, ch. 3.2.3), think function design emulate pattern keep semantics NA consistent across contexts.","code":""},{"path":"https://lhdjung.github.io/moder/articles/missings.html","id":"na-return-types","dir":"Articles","previous_headings":"Theory","what":"NA return types","title":"Modes and missing values","text":"function supposed return one modes returns NA instead, NA type input vector, x. Functions attempt count modes determine frequency ever return integers NA_integer_, .e., missing value type integer. However, differences NA types important (perhaps widely known). can usually disregarded.","code":""},{"path":"https://lhdjung.github.io/moder/articles/missings.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Modes and missing values","text":"Wickham, H. (2019). Advanced R (Second Edition), CRC Press/Taylor Francis Group. https://adv-r.hadley.nz/index.html.","code":""},{"path":"https://lhdjung.github.io/moder/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Lukas Jung. Author, maintainer.","code":""},{"path":"https://lhdjung.github.io/moder/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Jung L (2023). moder: Mode Estimation R. https://github.com/lhdjung/moder, https://lhdjung.github.io/moder/.","code":"@Manual{,   title = {moder: Mode Estimation in R},   author = {Lukas Jung},   year = {2023},   note = {https://github.com/lhdjung/moder, https://lhdjung.github.io/moder/}, }"},{"path":"https://lhdjung.github.io/moder/index.html","id":"mode-estimation-in-r","dir":"","previous_headings":"","what":"Mode estimation in R","title":"Mode estimation in R","text":"moder package determines single multiple modes (frequent values). default, functions check whether missing values make impossible, return NA case. dependencies. Mode functions fill gap measures central tendency R. mean() median() built standard library, lack properly NA-sensitive functions calculating mode. Use moder !","code":""},{"path":"https://lhdjung.github.io/moder/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Mode estimation in R","text":"can install development version moder like :","code":"remotes::install_github(\"lhdjung/moder\")"},{"path":"https://lhdjung.github.io/moder/index.html","id":"get-started","dir":"","previous_headings":"","what":"Get started","title":"Mode estimation in R","text":"","code":"library(moder)"},{"path":"https://lhdjung.github.io/moder/index.html","id":"find-the-first-mode-with-mode_first","dir":"","previous_headings":"Get started","what":"Find the first mode with mode_first()","title":"Mode estimation in R","text":"Everything fine : values missing? Maybe many missings ’s impossible tell value frequent one. NAs secretly 2, 2 (first) mode. Otherwise, 1 . mode unclear, function returns NA: Ignore NAs using na.rm = TRUE strong rationale : next example different. Even NA stands 8, three instances 8 four instances 7. mode 7, independent true value behind NA.","code":"mode_first(c(7, 8, 8, 9, 9, 9)) #> [1] 9 mode_first(c(1, 1, 2, NA, NA)) #> [1] NA mode_first(c(1, 1, 2, NA, NA), na.rm = TRUE) #> [1] 1 mode_first(c(7, 7, 7, 7, 8, 8, NA)) #> [1] 7"},{"path":"https://lhdjung.github.io/moder/index.html","id":"find-all-modes-with-mode_all","dir":"","previous_headings":"Get started","what":"Find all modes with mode_all()","title":"Mode estimation in R","text":"function captures multiple modes: values missing multiple modes ignoring NAs, mode_all() returns NA. ’s missings can easily create imbalance equally-frequent known values: NA masks either 1 2, number (single) mode. , mode depends missing values, function returns NA. Yet na.rm = TRUE makes function ignore :","code":"mode_all(c(\"a\", \"a\", \"b\", \"b\", \"c\", \"d\", \"e\")) #> [1] \"a\" \"b\" mode_all(c(1, 1, 2, 2, NA)) #> [1] NA mode_all(c(1, 1, 2, 2, NA), na.rm = TRUE) #> [1] 1 2"},{"path":"https://lhdjung.github.io/moder/index.html","id":"find-the-single-mode-or-na-with-mode_single","dir":"","previous_headings":"Get started","what":"Find the single mode (or NA) with mode_single()","title":"Mode estimation in R","text":"mode_single() stricter mode_first(): returns NA default multiple modes. Otherwise, works way.","code":"mode_single(c(3, 4, 4, 5, 5, 5)) #> [1] 5 mode_single(c(\"x\", \"x\", \"y\", \"y\", \"z\")) #> [1] NA"},{"path":"https://lhdjung.github.io/moder/index.html","id":"find-possible-modes","dir":"","previous_headings":"Get started","what":"Find possible modes","title":"Mode estimation in R","text":"minimal maximal sets modes possible given missing value:","code":"mode_possible_min(c(\"a\", \"a\", \"a\", \"b\", \"b\", \"c\", NA)) #> [1] \"a\" mode_possible_max(c(\"a\", \"a\", \"a\", \"b\", \"b\", \"c\", NA)) #> [1] \"a\" \"b\""},{"path":"https://lhdjung.github.io/moder/index.html","id":"acknowledgements","dir":"","previous_headings":"","what":"Acknowledgements","title":"Mode estimation in R","text":"Ken Williams’ mode functions Stack Overflow pivotal moder.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode-possible.html","id":null,"dir":"Reference","previous_headings":"","what":"Possible sets of modes — mode-possible","title":"Possible sets of modes — mode-possible","text":"mode_possible_min() mode_possible_max() determine minimal maximal sets modes among known modes, given number missing values.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode-possible.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Possible sets of modes — mode-possible","text":"","code":"mode_possible_min(x, multiple = FALSE)  mode_possible_max(x, multiple = FALSE)"},{"path":"https://lhdjung.github.io/moder/reference/mode-possible.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Possible sets of modes — mode-possible","text":"x vector search possible modes. multiple Boolean. multiple set TRUE, functions return multiple modes frequency, even values missing. Default FALSE NAs may tip balance values equally frequent among known values. Thus, multiple = TRUE, functions necessarily return minimal maximal sets modes, values might part sets.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode-possible.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Possible sets of modes — mode-possible","text":"default, vector minimal maximal possible sets modes (values tied frequent) x. functions determine possible modes missing values, return NA default (multiple = FALSE).","code":""},{"path":[]},{"path":"https://lhdjung.github.io/moder/reference/mode-possible.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Possible sets of modes — mode-possible","text":"","code":"# \"a\" is guaranteed to be a mode, # \"b\" might also be one, but # \"c\" is impossible: mode_possible_min(c(\"a\", \"a\", \"a\", \"b\", \"b\", \"c\", NA)) #> [1] \"a\" mode_possible_max(c(\"a\", \"a\", \"a\", \"b\", \"b\", \"c\", NA)) #> [1] \"a\" \"b\"  # Only `8` can possibly be the mode # because, even if `NA` is `7`, it's # still less frequent than `8`: mode_possible_min(c(7, 7, 8, 8, 8, 8, NA)) #> [1] 8 mode_possible_max(c(7, 7, 8, 8, 8, 8, NA)) #> [1] 8  # No clear minimal or maximal set # of modes because `NA` may tip # the balance between `1` and `2` # towards a single mode: mode_possible_min(c(1, 1, 2, 2, 3, 4, 5, NA)) #> [1] NA mode_possible_max(c(1, 1, 2, 2, 3, 4, 5, NA)) #> [1] NA  # With `multiple = TRUE`, the functions # return all values that might be part of # the min / max sets of modes; not these # sets themselves: mode_possible_min(c(1, 1, 2, 2, 3, 4, 5, NA), multiple = TRUE) #> [1] 1 2 mode_possible_max(c(1, 1, 2, 2, 3, 4, 5, NA), multiple = TRUE) #> [1] 1 2 3 4 5"},{"path":"https://lhdjung.github.io/moder/reference/mode_all.html","id":null,"dir":"Reference","previous_headings":"","what":"All modes — mode_all","title":"All modes — mode_all","text":"mode_all() returns set modes vector.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_all.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"All modes — mode_all","text":"","code":"mode_all(x, na.rm = FALSE)"},{"path":"https://lhdjung.github.io/moder/reference/mode_all.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"All modes — mode_all","text":"x vector search modes. na.rm Boolean. missing values x removed computation proceeds? Default FALSE.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_all.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"All modes — mode_all","text":"vector modes (values tied frequent) x. modes determined missing values, returns NA instead.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/moder/reference/mode_all.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"All modes — mode_all","text":"","code":"# Both `3` and `4` are the modes: mode_all(c(1, 2, 3, 3, 4, 4)) #> [1] 3 4  # Only `8` is: mode_all(c(8, 8, 9)) #> [1] 8  # Can't determine the modes here -- # `9` might be another mode: mode_all(c(8, 8, 9, NA)) #> [1] NA  # Either `1` or `2` could be a # single mode, depending on `NA`: mode_all(c(1, 1, 2, 2, NA)) #> [1] NA  # `1` is the most frequent value, # no matter what `NA` stands for: mode_all(c(1, 1, 1, 2, NA)) #> [1] 1  # Ignore `NA`s with `na.rm = TRUE` # (there should be good reasons for this!): mode_all(c(8, 8, 9, NA), na.rm = TRUE) #> [1] 8 mode_all(c(1, 1, 2, 2, NA), na.rm = TRUE) #> [1] 1 2"},{"path":"https://lhdjung.github.io/moder/reference/mode_count.html","id":null,"dir":"Reference","previous_headings":"","what":"Modal count — mode_count","title":"Modal count — mode_count","text":"mode_count() counts modes vector. Thin wrapper around mode_all().","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modal count — mode_count","text":"","code":"mode_count(x, na.rm = FALSE, max_unique = NULL)"},{"path":"https://lhdjung.github.io/moder/reference/mode_count.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modal count — mode_count","text":"x vector search modes. na.rm Boolean. missing values x removed computation proceeds? Default FALSE. max_unique Numeric string. maximum number unique values x known, set max_unique number. rules NAs represent values beyond number (see examples). Set \"known\" instead values beyond already known can occur. Default NULL, assumes maximum.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_count.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modal count — mode_count","text":"Integer. Number modes (values tied frequent) x. modes determined missing values, returns NA instead.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_count.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Modal count — mode_count","text":"","code":"# There are two modes, `3` and `4`: mode_count(c(1, 2, 3, 3, 4, 4)) #> [1] 2  # Only one mode, `8`: mode_count(c(8, 8, 9)) #> [1] 1  # Can't determine the number of modes # here -- `9` might be another mode: mode_count(c(8, 8, 9, NA)) #> [1] NA  # Either `1` or `2` could be a # single mode, depending on `NA`: mode_count(c(1, 1, 2, 2, NA)) #> [1] NA  # `1` is the most frequent value, # no matter what `NA` stands for: mode_count(c(1, 1, 1, 2, NA)) #> [1] 1  # Ignore `NA`s with `na.rm = TRUE` # (there should be good reasons for this!): mode_count(c(8, 8, 9, NA), na.rm = TRUE) #> [1] 1 mode_count(c(1, 1, 2, 2, NA), na.rm = TRUE) #> [1] 2"},{"path":"https://lhdjung.github.io/moder/reference/mode_count_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Modal count range — mode_count_range","title":"Modal count range — mode_count_range","text":"mode_count_range() determines minimal maximal number modes given number missing values.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_count_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modal count range — mode_count_range","text":"","code":"mode_count_range(x, max_unique = NULL)"},{"path":"https://lhdjung.github.io/moder/reference/mode_count_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modal count range — mode_count_range","text":"x vector search possible modes. max_unique Numeric string. maximum number unique values x known, set max_unique number. rules NAs represent values beyond number (see examples). Set \"known\" instead values beyond already known can occur. Default NULL, assumes maximum.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_count_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modal count range — mode_count_range","text":"Integer (length 2). Minimal maximal number modes (values tied frequent) x.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_count_range.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Modal count range — mode_count_range","text":"x factor, max_unique \"known\" warning. factor's levels supposed include possible values.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_count_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Modal count range — mode_count_range","text":"","code":"# If `NA` is `7` or `8`, that number is # the only mode; otherwise, both numbers # are modes: mode_count_range(c(7, 7, 8, 8, NA)) #> [1] 1 2  # Same result here -- `7` is the only mode # unless `NA` is secretly `8`, in which case # there are two modes: mode_count_range(c(7, 7, 7, 8, 8, NA)) #> [1] 1 2  # But now, there is now way for `8` to be # as frequent as `7`: mode_count_range(c(7, 7, 7, 7, 8, 8, NA)) #> [1] 1 1  # The `NA`s might form a new mode here # if they are both, e.g., `9`: mode_count_range(c(7, 7, 8, 8, NA, NA)) #> [1] 1 3  # However, if there can be no values beyond # those already known -- `7` and `8` -- # the `NA`s can't form a new mode. # Specify this with `max_unique = \"known\"`: mode_count_range(c(7, 7, 8, 8, NA, NA), max_unique = \"known\") #> [1] 1 2"},{"path":"https://lhdjung.github.io/moder/reference/mode_first.html","id":null,"dir":"Reference","previous_headings":"","what":"The first-appearing mode — mode_first","title":"The first-appearing mode — mode_first","text":"mode_first() returns mode appears first vector, .e., modes.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_first.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The first-appearing mode — mode_first","text":"","code":"mode_first(x, na.rm = FALSE, accept = FALSE)"},{"path":"https://lhdjung.github.io/moder/reference/mode_first.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The first-appearing mode — mode_first","text":"x vector search first mode. na.rm Boolean. missing values x removed computation proceeds? Default FALSE. accept Boolean. first-appearing value known mode accepted? FALSE (default), returns NA value appears earlier might another mode due missing values.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_first.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The first-appearing mode — mode_first","text":"first mode (frequent value) x. determined missing values, returns NA instead.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/moder/reference/mode_first.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The first-appearing mode — mode_first","text":"","code":"# `2` is most frequent: mode_first(c(1, 2, 2, 2, 3)) #> [1] 2  # Can't determine the first mode -- # it might be `1` or `2` depending # on the true value behind `NA: mode_first(c(1, 1, 2, 2, NA)) #> [1] NA  # Ignore `NA`s with `na.rm = TRUE` # (there should be good reasons for this!): mode_first(c(1, 1, 2, 2, NA), na.rm = TRUE) #> [1] 1  # `1` is the most frequent value, # no matter what `NA` stands for: mode_first(c(1, 1, 1, 2, NA)) #> [1] 1  # By default, the function insists on # the first mode, so it won't accept the # first value *known* to be a mode if an # earlier value might be a mode, too: mode_first(c(1, 2, 2, NA)) #> [1] NA  # You may accept the first-known mode: mode_first(c(1, 2, 2, NA), accept = TRUE) #> [1] 2"},{"path":"https://lhdjung.github.io/moder/reference/mode_frequency.html","id":null,"dir":"Reference","previous_headings":"","what":"Modal frequency — mode_frequency","title":"Modal frequency — mode_frequency","text":"Call mode_frequency() get number times vector's mode appears vector. See mode_frequency_range() bounds unknown frequency.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_frequency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modal frequency — mode_frequency","text":"","code":"mode_frequency(x, na.rm = FALSE, max_unique = NULL)"},{"path":"https://lhdjung.github.io/moder/reference/mode_frequency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modal frequency — mode_frequency","text":"x vector check modal frequency. na.rm Boolean. missing values x removed computation proceeds? Default FALSE. max_unique Numeric string. maximum number unique values x known, set max_unique number. rules NAs represent values beyond number (see examples). Set \"known\" instead values beyond already known can occur. Default NULL, assumes maximum.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_frequency.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modal frequency — mode_frequency","text":"Integer (length 1) NA.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_frequency.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Modal frequency — mode_frequency","text":"default (na.rm = FALSE), function returns NA values missing. missings make frequency uncertain even mode known: missing value may may mode, hence count towards modal frequency.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/moder/reference/mode_frequency.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Modal frequency — mode_frequency","text":"","code":"# The mode, `9`, appears three times: mode_frequency(c(7, 8, 8, 9, 9, 9)) #> [1] 3  # With missing values, the frequency # is unknown, even if the mode isn't: mode_frequency(c(1, 1, NA)) #> [1] NA  # You can ignore this problem and # determine the frequency among known values # (there should be good reasons for this!): mode_frequency(c(1, 1, NA), na.rm = TRUE) #> [1] 2"},{"path":"https://lhdjung.github.io/moder/reference/mode_frequency_range.html","id":null,"dir":"Reference","previous_headings":"","what":"Modal frequency range — mode_frequency_range","title":"Modal frequency range — mode_frequency_range","text":"mode_frequency_range() determines minimum maximum number times vector's mode appears vector. minimum assumes NAs mode; maximum assumes NAs .","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_frequency_range.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modal frequency range — mode_frequency_range","text":"","code":"mode_frequency_range(x, max_unique = NULL)"},{"path":"https://lhdjung.github.io/moder/reference/mode_frequency_range.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modal frequency range — mode_frequency_range","text":"x vector check modal frequency. max_unique Numeric string. maximum number unique values x known, set max_unique number. rules NAs represent values beyond number (see examples). Set \"known\" instead values beyond already known can occur. Default NULL, assumes maximum.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_frequency_range.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modal frequency range — mode_frequency_range","text":"Integer (length 2).","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_frequency_range.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Modal frequency range — mode_frequency_range","text":"NAs x, two return values identical. x values NA, return values 1 (two x values ) total number values (x values ).","code":""},{"path":[]},{"path":"https://lhdjung.github.io/moder/reference/mode_frequency_range.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Modal frequency range — mode_frequency_range","text":"","code":"# The mode is `7`. It appears four or # five times because the `NA` might # also be a `7`: mode_frequency_range(c(7, 7, 7, 7, 8, 8, NA)) #> [1] 4 5  # All of `\"c\"`, `\"d\"`, and `\"e\"` are the modes, # and each of them appears twice: mode_frequency_range(c(\"a\", \"b\", \"c\", \"c\", \"d\", \"d\", \"e\", \"e\")) #> [1] 2 2"},{"path":"https://lhdjung.github.io/moder/reference/mode_is_trivial.html","id":null,"dir":"Reference","previous_headings":"","what":"Is the mode trivial? — mode_is_trivial","title":"Is the mode trivial? — mode_is_trivial","text":"mode_is_trivial() checks whether values given vector equally frequent. mode informative cases.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_is_trivial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is the mode trivial? — mode_is_trivial","text":"","code":"mode_is_trivial(x, na.rm = FALSE, max_unique = NULL)"},{"path":"https://lhdjung.github.io/moder/reference/mode_is_trivial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is the mode trivial? — mode_is_trivial","text":"x vector search modes. na.rm Boolean. missing values x removed computation proceeds? Default FALSE. max_unique Numeric string. maximum number unique values x known, set max_unique number. rules NAs represent values beyond number (see examples). Set \"known\" instead values beyond already known can occur. Default NULL, assumes maximum.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_is_trivial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is the mode trivial? — mode_is_trivial","text":"Boolean (length 1).","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_is_trivial.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Is the mode trivial? — mode_is_trivial","text":"function returns TRUE whenever x length < 3 value frequent another one. Otherwise, returns NA cases: x values missing known values equal. Thus, unknown whether value different frequency. known values modes NAs \"fill \" non-modal values exactly, .e., without NAs remaining. NAs remain \"filling \" non-modal values NAs (hypothetically modes), number remaining NAs divisible number unique known values. many missing values might form mode-sized groups values among known values, number NAs divisible modal frequency (partly hypothetical) values might equally frequent. can limit number hypothetical values specifying max_unique. function might return FALSE instead NA.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_is_trivial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is the mode trivial? — mode_is_trivial","text":"","code":"# The mode is trivial if # all values are equal... mode_is_trivial(c(1, 1, 1)) #> [1] TRUE  # ...and even if all unique # values are equally frequent: mode_is_trivial(c(1, 1, 2, 2)) #> [1] TRUE  # It's also trivial if # all values are different: mode_is_trivial(c(1, 2, 3)) #> [1] TRUE  # Here, the mode is nontrivial # because `1` is more frequent than `2`: mode_is_trivial(c(1, 1, 2)) #> [1] FALSE  # Two of the `NA`s might be `8`s, and # the other three might represent a value # different from both `7` and `8`. Thus, # it's possible that all three distinct # values are equally frequent: mode_is_trivial(c(7, 7, 7, 8, rep(NA, 5))) #> [1] NA  # The same is not true if all values, # even the missing ones, must represent # one of the known values: mode_is_trivial(c(7, 7, 7, 8, rep(NA, 5)), max_unique = \"known\") #> [1] FALSE"},{"path":"https://lhdjung.github.io/moder/reference/mode_single.html","id":null,"dir":"Reference","previous_headings":"","what":"The single mode — mode_single","title":"The single mode — mode_single","text":"mode_single() returns mode vector. multiple modes, returns NA default.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The single mode — mode_single","text":"","code":"mode_single(x, na.rm = FALSE, accept = FALSE, multiple = \"NA\")"},{"path":"https://lhdjung.github.io/moder/reference/mode_single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The single mode — mode_single","text":"x vector search mode. na.rm Boolean. missing values x removed computation proceeds? Default FALSE. accept Boolean. minimum set modes accepted check single mode? FALSE (default), insists complete set returns NA determined. multiple String integer (length 1), function. x multiple modes. default returns NA. options rely modal values: \"min\", \"max\", \"mean\", \"median\", \"first\", \"last\", \"random\". Alternatively, multiple can index number, function summarizes modes. See details.","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_single.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The single mode — mode_single","text":"mode (frequent value) x. determined missing values, NA returned instead. default, NA also returned multiple modes (multiple = \"NA\").","code":""},{"path":"https://lhdjung.github.io/moder/reference/mode_single.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The single mode — mode_single","text":"accept FALSE (default), set modes obtained via mode_all() instead mode_possible_min(). Set TRUE avoid returning NA , though modes known. purpose default insist single mode. x string vector multiple \"min\" \"max\", mode selected lexically, just like min(letters) returns \"\". \"mean\" \"median\" options return NA warning. factors, \"min\", \"max\", \"median\" errors, \"mean\" returns NA warning. inconsistencies base R. multiple options \"first\" \"last\" always select mode appears first last x. Index numbers, like multiple = 2, allow select flexibly. multiple function, output must length 1.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/moder/reference/mode_single.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The single mode — mode_single","text":"","code":"# `8` is the only mode: mode_single(c(8, 8, 9)) #> [1] 8  # With more than one mode, the function # returns `NA`: mode_single(c(1, 2, 3, 3, 4, 4)) #> [1] NA  # Can't determine the modes here -- # `9` might be another mode: mode_single(c(8, 8, 9, NA)) #> [1] NA  # Accept `8` anyways if it's # sufficient to just have any mode: mode_single(c(8, 8, 9, NA), accept = TRUE) #> [1] 8  # `1` is the most frequent value, # no matter what `NA` stands for: mode_single(c(1, 1, 1, 2, NA)) #> [1] 1  # Ignore `NA`s with `na.rm = TRUE` # (there should be good reasons for this!): mode_single(c(8, 8, 9, NA), na.rm = TRUE) #> [1] 8"},{"path":"https://lhdjung.github.io/moder/news/index.html","id":"moder-020","dir":"Changelog","previous_headings":"","what":"moder 0.2.0","title":"moder 0.2.0","text":"mode_count() metadata functions now max_unique argument, allowing users encode knowledge missing values analysis. mode_single() now accept argument opting less strict check single mode, analogy mode_first(). mode_first() first_known argument renamed accept consistency mode_single(). improvements documentation, including vignettes.","code":""},{"path":"https://lhdjung.github.io/moder/news/index.html","id":"moder-011","dir":"Changelog","previous_headings":"","what":"moder 0.1.1","title":"moder 0.1.1","text":"Fixed incongruencies documentation warnings. Established ⁠R CMD check Github Actions.","code":""},{"path":"https://lhdjung.github.io/moder/news/index.html","id":"moder-010","dir":"Changelog","previous_headings":"","what":"moder 0.1.0","title":"moder 0.1.0","text":"mode_is_trivial() mode_frequency() mode_count_range() mode_frequency_range() New vignettes missing values, metadata, performance. Many bugfixes improvements.","code":""},{"path":"https://lhdjung.github.io/moder/news/index.html","id":"moder-001","dir":"Changelog","previous_headings":"","what":"moder 0.0.1","title":"moder 0.0.1","text":"Added NEWS.md file track changes package.","code":""}]
