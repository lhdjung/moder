% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predicates.R
\name{mode_is_trivial}
\alias{mode_is_trivial}
\title{Is the mode trivial?}
\usage{
mode_is_trivial(x, na.rm = FALSE, exclusive = FALSE)
}
\arguments{
\item{x}{A vector to search for its modes.}

\item{na.rm}{Boolean. Should missing values in \code{x} be removed before
computation proceeds? Default is \code{FALSE}.}

\item{exclusive}{Boolean. Can \code{NA}s only represent known values? Set
\code{exclusive} to \code{TRUE} if you are certain that there are no other values
behind the \code{NA}s, such that each \code{NA} masks one of the known values.
Default is \code{FALSE}.}
}
\value{
Boolean (length 1).
}
\description{
\code{mode_is_trivial()} checks whether all values in a given vector
are equally frequent. The mode is not too informative in such cases.
}
\details{
The function returns \code{TRUE} whenever \code{x} has length < 3 because no
value is more frequent than another one. Otherwise, it returns \code{NA} in
these cases:
\itemize{
\item Some \code{x} values are missing and all known values are equal. Thus, it is
unknown whether there is a value with a different frequency.
\item All known values are modes if the \code{NA}s "fill up" the non-modal values
exactly, i.e., without any \code{NA}s remaining.
\item There are so many missing values that they might form mode-sized groups
of values that are not among the known values, and the number of missing
values is divisible by the number of unique known values (even after
"filling up" the non-modal values with \code{NA}s so that they are
hypothetically modes). Suppress this behavior by setting \code{exclusive} to
\code{TRUE} if you are certain that there are no values in \code{x} other than those
already known to occur. The function will then return \code{FALSE} instead of
\code{NA}.
}
}
\examples{
# The mode is trivial if
# all values are equal...
mode_is_trivial(c(1, 1, 1))

# ...and even if all unique
# values are equally frequent:
mode_is_trivial(c(1, 1, 2, 2))

# It's also trivial if
# all values are different:
mode_is_trivial(c(1, 2, 3))

# Here, the mode is nontrivial
# because `1` is more frequent than `2`:
mode_is_trivial(c(1, 1, 2))
}
